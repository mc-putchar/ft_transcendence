diff --git a/pong/static/js/pong3d.js b/pong/static/js/pong3d.js
index 10b9ac6..a25dbed 100644
--- a/pong/static/js/pong3d.js
+++ b/pong/static/js/pong3d.js
@@ -3,18 +3,19 @@ import { OrbitControls } from 'three/addons/controls/OrbitControls';
 import { FontLoader } from 'three/addons/loaders/FontLoader.js';
 import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
 
-import { getAmps, playAudioTrack, playTone } from './audio.js';
+import { getAmps, playTone } from './audio.js';
 
+const ACTIVE_AI = true;
 
 const CANVAS_PADDING = 10;
-const BALL_SIZE = 8;
+const BALL_SIZE = 6;
 const ARENA_WIDTH = 300;
 const ARENA_HEIGHT = 200;
 const SCORE_HEIGHT = 42;
 const GOAL_LINE = 20;
 const NET_WIDTH = 4;
 const NET_HEIGHT = 30;
-const BALL_START_SPEED = 2;
+const BALL_START_SPEED = 2 / 16;
 const PADDLE_SPEED = 5;
 const PADDLE_LEN = 42;
 const PADDLE_WIDTH = 6;
@@ -24,11 +25,10 @@ const DRAW_DISTANCE = 1000;
 const AVATAR_HEIGHT = PADDLE_HEIGHT + 2;
 const WALL_HEIGHT = 20;
 const WALL_THICKNESS = 10;
-const CAM_START_X = -160;
-const CAM_START_Y = 130;
+const CAM_START_X = -150;
+const CAM_START_Y = 200;
 
 const SCORE_FONT = "static/fonts/helvetiker_regular.typeface.json";
-const WIN_FONT = "static/fonts/optimer_regular.typeface.json";
 const BALL_TEX_IMG = "static/img/green-texture.avif"
 const WALL_TEX_IMG = "static/img/matrix-purple.jpg"
 const AVATAR1_IMG = "static/img/avatar.jpg"
@@ -92,8 +92,6 @@ class Arena {
 		scene.add( this.spotLight );
 		scene.add(this.ambient_light);
 		scene.add(this.plane);
-		// scene.add(this.grid);
-		// scene.add( this.lightHelper, this.lightHelper1, this.lightHelper2 );
 	}
 };
 
@@ -104,6 +102,7 @@ class Ball {
 		this.pos = new THREE.Vector3();
 		this.dir = new THREE.Vector3();
 		this.speed = 0;
+		this.lastMove = 0;
 	}
 	place(scene, x, z) {
 		this.mesh.position.set(x, BALL_SIZE, z);
@@ -113,9 +112,16 @@ class Ball {
 		this.mesh.getWorldPosition(this.pos);
 		return [this.pos.x, this.pos.z];
 	}
+	get direction() {
+		return [this.dir.x, this.dir.z];
+	}
 	doMove() {
-		this.mesh.translateX(this.dir.x * this.speed);
-		this.mesh.translateZ(this.dir.z * this.speed);
+		if(this.lastMove == 0 || Date.now() - this.lastMove > 100 || Date.now() - this.lastMove <= 4)
+			this.lastMove = Date.now();
+		this.time = Date.now() - this.lastMove;
+		this.mesh.translateX(this.dir.x * this.speed * this.time);
+		this.mesh.translateZ(this.dir.z * this.speed * this.time);
+		this.lastMove = Date.now();
 	}
 	reset() {
 		this.mesh.position.set(0, BALL_SIZE, 0);
@@ -131,13 +137,14 @@ class Player {
 		this.len = PADDLE_LEN;
 		this.score = 0;
 		this.direction = 0;
+		this.keys_active = 0;
 		this.speed = PADDLE_SPEED;
 
 		this.avatar = new THREE.Mesh(
 			new THREE.BoxGeometry(10, 10, 10),
-			new THREE.MeshLambertMaterial({ map: avatar_tex, })
+			new THREE.MeshBasicMaterial({ map: avatar_tex, })
 			);
-		const wire_material = new THREE.MeshLambertMaterial({ color: 0x42FF42, wireframe: true });
+		const wire_material = new THREE.MeshBasicMaterial({ color: 0x42FF42, wireframe: true });
 		this.avatar_box = new THREE.Mesh(
 			new THREE.BoxGeometry(11, 11, 11),
 			wire_material
@@ -166,6 +173,141 @@ class Player {
 	}
 };
 
+// direction 1 is up
+// X for ARENA HEIGHT
+// Z for ARENA WIDTH
+
+class proAI {
+	constructor (player) {
+		this.player = player;
+		this.lastMove = 0;
+		this.objective = 0;
+		this.msc = 21;
+		this.time = {x : null, z : null};
+		this.distance;
+		this.randomMargin = 10;
+		this.wait = 0; // time before it hits left paddle
+		this.timeOfImpact = 0; // time before it hits right paddle
+		this.roundsTillImpact = 0;
+	}
+	nextCollision(simBall) {
+		this.endZ;
+
+		this.endX = - (ARENA_HEIGHT / 2);
+		if(simBall.dirX > 0)
+			this.endX = ARENA_HEIGHT / 2;
+		this.time.x = Math.abs((this.endX - simBall.posX) / simBall.dirX);
+
+		if(simBall.dirZ > 0)
+			this.time.z = Math.abs((ARENA_WIDTH / 2 - simBall.posZ) / simBall.dirZ);
+		
+		if(this.time.x < this.time.z) {
+			this.endZ = this.time.x * simBall.dirZ + simBall.posZ;
+			simBall.dirX *= - 1;
+			this.distance = Math.abs(simBall.posX - this.endX);
+		}
+		else {
+			this.endX = this.time.z * simBall.dirX + simBall.posX;
+			if(simBall.dirZ > 0)
+				this.endZ = ARENA_WIDTH / 2;
+			else {
+				this.endZ = - ARENA_WIDTH / 2;
+			}
+			simBall.dirZ *= - 1;
+			this.endX = this.time.z * simBall.dirX + simBall.posX;
+			this.distance = Math.abs(simBall.posZ - this.endZ);
+		}
+		// this.distance = Math.abs(this.endX - simBall.posX) + Math.abs(this.endZ - simBall.posZ);
+		simBall.posX = this.endX;
+		simBall.posZ = this.endZ;
+	}
+	setObjective(simBall) {
+		let rounds = 0;
+		let rand = Math.random();
+		this.timeOfImpact = 0;
+		while(simBall.posZ != ARENA_WIDTH / 2 && rounds < 8) {
+			this.nextCollision(simBall);
+			this.timeOfImpact += this.distance / simBall.speed;
+			rounds++;
+		}
+		this.timeOfImpact += Date.now();
+		this.roundsTillImpact = rounds;
+		this.objective = simBall.posX - this.randomMargin / 2 + this.randomMargin * rand;
+	}
+	setWait(simBall) {
+		this.wait = 0;
+		let rounds = 0;
+		if(simBall.dirZ > 0) { // hits AI paddle first so then we want to reposition the paddle strategically in anticipation and estimate when ball will hit the left paddle
+			// let refAngle = (ballX - p1x) / (PADDLE_LEN / 2) * (Math.PI / 4);
+			// this.ball.dir.setZ(-1 * Math.cos(refAngle));
+			// this.ball.dir.setX(Math.sin(refAngle));
+			while(simBall.posZ < (ARENA_WIDTH / 2) && rounds < 9) {
+				this.nextCollision(simBall);
+				this.wait += this.distance / simBall.speed;
+				rounds++;
+			}
+			let refAngle = (this.objective - this.player.pos.x) / (PADDLE_LEN / 2) * (Math.PI / 4);
+			simBall.dirZ = -1 * Math.cos(refAngle);
+			simBall.dirX = Math.sin(refAngle);
+			
+			rounds = 0;
+			while(simBall.posZ != - (ARENA_WIDTH / 2) && rounds < 9) {
+				this.nextCollision(simBall);
+				this.wait += this.distance / simBall.speed;
+				rounds++;
+			}
+			console.log("wait1: ", this.wait);
+			console.log("estimation: ", this.wait + Date.now());
+			
+		}
+		if(simBall.dirZ < 0) { // we want to know when it will hit the left paddle
+			while(simBall.posZ != - (ARENA_WIDTH / 2) && rounds < 9) {
+				this.nextCollision(simBall);
+				this.wait += this.distance / simBall.speed;
+				rounds++;
+			}
+			if(rounds > 5) {
+				this.wait = 0;
+			}
+			console.log("wait2: ", this.wait);
+			console.log("estimation: ", this.wait + Date.now());
+		}
+	}
+	stopMove() {
+		if(this.player.direction == 1 && this.player.pos.x >= this.objective) {
+			this.player.direction = 0;
+		}
+		else if(this.player.direction == -1 && this.player.pos.x <= this.objective) {
+			this.player.direction = 0;
+		}
+	}
+	setDirection() {
+		if(this.player.pos.x < this.objective)
+			this.player.direction = 1;
+		else
+			this.player.direction = -1;
+	}
+	executeMove(ball) {
+		if(Date.now() < this.lastMove + 1000 || (Date.now() < this.lastMove + this.wait + 21 / ball.speed))
+			return ;
+		this.lastMove = Date.now();
+		this.simBall = { posX : ball.pos.x, posZ : ball.pos.z, dirX : ball.dir.x, dirZ : ball.dir.z, speed : ball.speed};
+		this.setObjective(this.simBall);
+		this.setDirection();
+		this.simBall = { posX : ball.pos.x, posZ : ball.pos.z, dirX : ball.dir.x, dirZ : ball.dir.z, speed : ball.speed};
+		this.setWait(this.simBall);
+	}
+	update(ball) {
+		// if(this.timeOfImpact != 0 && this.roundsTillImpact < 3 && Date.now() > this.timeOfImpact + 50 && this.player.direction == 0) {
+		// 	console.log("TRUE timeofimpact: ", this.timeOfImpact);
+		// 	this.objective = 0;
+		// 	this.setDirection();
+		// }
+		this.stopMove();
+		this.executeMove(ball);
+	}
+}
+
 class Game {
 	constructor(parentElement, scoreLimit) {
 		this.parent = parentElement;
@@ -208,7 +350,9 @@ class Game {
 		const ball_mat = new THREE.MeshPhongMaterial({ map: ball_texture });
 		const ball_geometry = new THREE.SphereGeometry( BALL_SIZE, 32, 16 )
 		this.ball = new Ball(ball_geometry, ball_mat);
+		
 		this.ball.place(this.scene, 0, 0);
+		this.saved = {x: this.ball.dir.x, y: this.ball.dir.y};
 
 		const wire_material = new THREE.MeshPhongMaterial({ color: 0x42FF42, wireframe: true });
 		const box_geometry = new THREE.BoxGeometry(PADDLE_LEN, PADDLE_HEIGHT, PADDLE_WIDTH, 8, 2, 2);
@@ -230,11 +374,13 @@ class Game {
 		this.scoreLimit = scoreLimit;
 		this.gameover = false;
 
+		
 		document.addEventListener("keydown", ev => this.keydown(ev));
 		document.addEventListener("keyup", ev => this.keyup(ev));
 
+		if(ACTIVE_AI == true)
+			this.ai = new proAI(this.playerTwo);
 		this.showScore();
-		playAudioTrack();
 	}
 	toggleFullScreen() {
 		if (this.renderer.domElement.requestFullscreen) {
@@ -270,15 +416,23 @@ class Game {
 		}
 		switch(key.code) {
 			case "ArrowUp":
+				if(this.playerOne.direction != 1)
+					this.playerOne.keys_active++;
 				this.playerOne.direction = 1;
 				break;
 			case "ArrowDown":
+				if(this.playerOne.direction != -1)
+					this.playerOne.keys_active++;
 				this.playerOne.direction = -1;
 				break;
 			case "KeyW":
+				if(this.playerTwo.direction != 1)
+					this.playerTwo.keys_active++;
 				this.playerTwo.direction = 1;
 				break;
 			case "KeyS":
+				if(this.playerTwo.direction != -1)
+					this.playerTwo.keys_active++;
 				this.playerTwo.direction = -1;
 				break;
 			default:
@@ -288,9 +442,13 @@ class Game {
 	keyup(key) {
 		if (this.gameover)	return;
 		if (key.code == "ArrowUp" || key.code == "ArrowDown") {
-			this.playerOne.direction = 0;
+			this.playerOne.keys_active--;
+			if(this.playerOne.keys_active == 0)
+				this.playerOne.direction = 0;
 		} else if (key.code == "KeyW" || key.code == "KeyS") {
-			this.playerTwo.direction = 0;
+			this.playerTwo.keys_active--;
+			if(this.playerTwo.keys_active == 0)
+				this.playerTwo.direction = 0;
 		}
 	}
 	endGame() {
@@ -307,6 +465,15 @@ class Game {
 	}
 	loop() {
 		this.animRequestId = window.requestAnimationFrame(this.loop.bind(this));
+		// console.log(this.playerTwo.position);
+		// if(this.saved.x != this.ball.dir.x || this.saved.y != this.ball.dir.y)
+		// {
+		// 	console.log("BALL POS: ", this.ball.pos);
+		// 	console.log("BALL DIR: ", this.ball.dir);
+		// 	debugger;
+		// 	this.saved = {x: this.ball.dir.x, y: this.ball.dir.y};
+		// }
+		this.ai.update(this.ball);
 		if (!this.gameover) {
 			let now = Date.now();
 			let elapsed = now - this.lastUpdate;
@@ -325,7 +492,6 @@ class Game {
 			this.arena.bottomWalls[i].position.y = (50 - this.amps[i + 1])/-5;
 			if (i === 6) {
 				this.arena.lightbulb1.intensity = this.amps[i + 1] * 50;
-				// console.log(this.arena.lightbulb1.intensity);
 			} else if (i === 5) {
 				this.arena.lightbulb2.intensity = this.amps[i + 1] * 50;
 			}
@@ -361,6 +527,7 @@ class Game {
 			this.playerTwo.score++;
 			this.scene.remove(this.score);
 			this.showScore();
+			debugger;
 		} else if (ballY > ARENA_WIDTH / 2 + GOAL_LINE) {
 			playTone(240, 20, 210, 3);
 			this.last_scored = 1;
@@ -369,22 +536,27 @@ class Game {
 			this.playerOne.score++;
 			this.scene.remove(this.score);
 			this.showScore();
+			debugger;
 		} else if (ballY + BALL_SIZE >= p2y - (PADDLE_WIDTH / 2)
 		&& (ballY + BALL_SIZE < (ARENA_WIDTH / 2))
-		&& (ballX < p2x + (PADDLE_LEN / 2) && ballX > p2x - (PADDLE_LEN / 2))) {
+		&& (ballX < p2x + (PADDLE_LEN / 2) && ballX > p2x - (PADDLE_LEN / 2))) { // HITS RIGHT PADDLE aka AI PADDLE
+			console.log("HIT PADDLE X: ", ballX, ", Z: ", ballY);
+			console.log("TIME: ", Date.now());
 			playTone(200, 30, 200, 0.6);
 			let refAngle = (ballX - p2x) / (PADDLE_LEN / 2) * (Math.PI / 4);
 			this.ball.dir.setZ(-1 * Math.cos(refAngle));
 			this.ball.dir.setX(Math.sin(refAngle));
-			this.ball.speed += 0.1;
+			this.ball.speed += 1 / 64;
 		} else if (ballY - BALL_SIZE <= p1y + (PADDLE_WIDTH / 2)
 		&& (ballY + BALL_SIZE > -ARENA_WIDTH / 2)
 		&& (ballX < p1x + (PADDLE_LEN / 2) && ballX > p1x - (PADDLE_LEN / 2))) {
+			console.log("HIT LEFT X: ", ballX, ", Z: ", ballY);
+			console.log("TIME: ", Date.now());
 			playTone(200, 30, 200, 0.6);
 			let refAngle = (ballX - p1x) / (PADDLE_LEN / 2) * (Math.PI / 4);
 			this.ball.dir.setZ(1 * Math.cos(refAngle));
 			this.ball.dir.setX(Math.sin(refAngle));
-			this.ball.speed += 0.1;
+			this.ball.speed += 1 / 64;
 		}
 	}
 	showScore() {
@@ -461,19 +633,17 @@ class Game {
 	}
 }
 
-function startPong3DGame() {
+export function startPong3DGame() {
 	console.log("Pong 3D - Starting new game");
 	const parent = document.getElementById('app');
 	const nav = document.getElementById('nav');
-	const footer = document.getElementById('footer');
 
-	parent.height = window.innerHeight - nav.offsetHeight - footer.offsetHeight - CANVAS_PADDING;
-	parent.width = window.innerWidth - CANVAS_PADDING;
+	parent.height = screen.availHeight - (window.outerHeight - window.innerHeight) - nav.offsetHeight - CANVAS_PADDING;
+	parent.width = screen.availWidth - (window.outerWidth - window.innerWidth);
 	while (parent.firstChild) {
 		parent.removeChild(parent.lastChild);
 	}
-	const pong = new Game(parent, 11);
+	const pong = new Game(parent);
 	pong.loop();
 }
-
-export { startPong3DGame };
+window.startPong3DGame = startPong3DGame;
